#!/usr/bin/env python3

"""
Basicmicro ROS2 Node
====================

Main ROS2 node for the Basicmicro motor controller driver.
This node provides a simple interface for testing hardware connectivity
and basic motor control via ROS2 topics and services.

Author: Generated by Claude Code for Basicmicro ROS2 Driver
License: Apache-2.0
"""

import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from sensor_msgs.msg import JointState
from std_msgs.msg import String, Float32
from diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue
import sys
import os

# Add the Basicmicro_python directory to Python path
sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'Basicmicro_python'))

try:
    from basicmicro import Basicmicro
except ImportError as e:
    print(f"Error importing Basicmicro library: {e}")
    print("Make sure the Basicmicro_python library is installed")
    sys.exit(1)

import math
import time
from threading import Lock


class BasicmicroNode(Node):
    """Main ROS2 node for Basicmicro motor controller."""
    
    def __init__(self):
        super().__init__('basicmicro_node')
        
        # Declare parameters
        self.declare_parameter('port', '/dev/ttyACM0')
        self.declare_parameter('baud', 38400)
        self.declare_parameter('address', 128)  # 0x80
        self.declare_parameter('wheel_radius', 0.1)  # meters
        self.declare_parameter('wheel_separation', 0.3)  # meters
        self.declare_parameter('encoder_counts_per_rev', 1000)
        self.declare_parameter('gear_ratio', 1.0)
        self.declare_parameter('max_speed', 2500)  # counts/sec (safety limit)
        
        # Get parameters
        self.port = self.get_parameter('port').get_parameter_value().string_value
        self.baud = self.get_parameter('baud').get_parameter_value().integer_value
        self.address = self.get_parameter('address').get_parameter_value().integer_value
        self.wheel_radius = self.get_parameter('wheel_radius').get_parameter_value().double_value
        self.wheel_separation = self.get_parameter('wheel_separation').get_parameter_value().double_value
        self.encoder_counts_per_rev = self.get_parameter('encoder_counts_per_rev').get_parameter_value().integer_value
        self.gear_ratio = self.get_parameter('gear_ratio').get_parameter_value().double_value
        self.max_speed = self.get_parameter('max_speed').get_parameter_value().integer_value
        
        # Calculate conversion factors
        self.wheel_circumference = 2 * math.pi * self.wheel_radius
        self.counts_per_meter = (self.encoder_counts_per_rev * self.gear_ratio) / self.wheel_circumference
        self.radians_per_count = (2 * math.pi) / (self.encoder_counts_per_rev * self.gear_ratio)
        
        # Initialize hardware connection (USB Serial or Async Serial)
        self.controller = None
        self.connected = False
        self.controller_lock = Lock()
        
        # State tracking
        self.last_encoder_left = 0
        self.last_encoder_right = 0
        self.position_left = 0.0  # radians
        self.position_right = 0.0  # radians
        self.velocity_left = 0.0  # rad/s
        self.velocity_right = 0.0  # rad/s
        
        # Connection health monitoring (CAN-like error rate system)
        self.error_count = 0
        self.max_error_count = 100  # Maximum errors before declaring connection bad
        self.error_recovery_rate = 1.0  # Reduce error count by 1 every N seconds
        self.last_error_recovery = time.time()
        self.consecutive_errors = 0
        self.max_consecutive_errors = 10  # Trigger warning after N consecutive errors
        self.connection_state = "good"  # "good", "degraded", "failed"
        self.last_health_check = time.time()
        self.health_check_interval = 5.0  # seconds
        
        # ROS2 Publishers
        self.odom_pub = self.create_publisher(Odometry, 'odom', 10)
        self.joint_state_pub = self.create_publisher(JointState, 'joint_states', 10)
        self.diagnostics_pub = self.create_publisher(DiagnosticArray, 'diagnostics', 10)
        self.status_pub = self.create_publisher(String, 'basicmicro/status', 10)
        
        # ROS2 Subscribers
        self.cmd_vel_sub = self.create_subscription(
            Twist, 'cmd_vel', self.cmd_vel_callback, 10)
        
        # Connect to hardware
        self.connect_hardware()
        
        # Create timers
        self.sensor_timer = self.create_timer(0.02, self.read_sensors)  # 50Hz
        self.diagnostics_timer = self.create_timer(1.0, self.publish_diagnostics)  # 1Hz
        self.connection_monitor_timer = self.create_timer(2.0, self.monitor_connection)  # 0.5Hz
        
        self.get_logger().info(f"Basicmicro node started")
        self.get_logger().info(f"Port: {self.port}, Baud: {self.baud}, Address: {self.address}")
        self.get_logger().info(f"Wheel radius: {self.wheel_radius}m, Separation: {self.wheel_separation}m")
        self.get_logger().info(f"Encoder CPR: {self.encoder_counts_per_rev}, Gear ratio: {self.gear_ratio}")
        
    def connect_hardware(self):
        """Connect to the Basicmicro controller."""
        try:
            # Close existing connection if any
            if self.controller:
                try:
                    self.controller.close()
                except:
                    pass
                    
            self.controller = Basicmicro(self.port, self.baud)
            if self.controller.Open():
                # Read version to verify connection
                version = self.controller.ReadVersion(self.address)
                if version[0]:  # Success
                    self.connected = True
                    self.error_count = 0  # Reset error count on successful connection
                    self.consecutive_errors = 0  # Reset consecutive error count
                    self.connection_state = "good"
                    self.last_health_check = time.time()
                    self.get_logger().info(f"Connected to controller: {version[1]}")
                    
                    # Reset encoders to start from zero
                    self.controller.ResetEncoders(self.address)
                    self.get_logger().info("Encoders reset to zero")
                    
                    return True
                else:
                    self.get_logger().error("Failed to read controller version")
            else:
                self.get_logger().error("Failed to open serial connection")
                
        except Exception as e:
            self.get_logger().error(f"Hardware connection error: {e}")
            
        self.connected = False
        return False
        
    def monitor_connection(self):
        """Monitor connection health using CAN-like error rate system."""
        current_time = time.time()
        
        # Automatic error recovery (reduce error count over time)
        if current_time - self.last_error_recovery >= self.error_recovery_rate:
            if self.error_count > 0:
                self.error_count -= 1
                self.last_error_recovery = current_time
                
        # Update connection state based on error count
        if self.error_count >= self.max_error_count:
            if self.connection_state != "failed":
                self.connection_state = "failed"
                self.connected = False
                self.get_logger().error(f"Connection failed - error count reached {self.max_error_count}. User intervention required.")
                # Publish error status
                status_msg = String()
                status_msg.data = f"CONNECTION_FAILED:ERROR_COUNT_{self.error_count}"
                self.status_pub.publish(status_msg)
        elif self.consecutive_errors >= self.max_consecutive_errors:
            if self.connection_state != "degraded":
                self.connection_state = "degraded"
                self.get_logger().warn(f"Connection degraded - {self.consecutive_errors} consecutive errors")
        elif self.error_count < 10 and self.consecutive_errors < 3:
            if self.connection_state != "good":
                self.connection_state = "good"
                self.get_logger().info("Connection health restored")
                
        # Periodic health check when idle
        if self.connected and current_time - self.last_health_check >= self.health_check_interval:
            self.perform_health_check()
            self.last_health_check = current_time
            
    def perform_health_check(self):
        """Perform periodic health check by reading controller status."""
        if not self.connected:
            return
            
        with self.controller_lock:
            try:
                # Try a simple health check - read temperature
                temps = self.controller.GetTemps(self.address)
                if temps[0]:  # Success
                    self.record_command_success()
                    self.get_logger().debug("Health check passed")
                else:
                    self.record_command_error("Health check failed - temperature read failed")
                    
            except Exception as e:
                self.record_command_error(f"Health check failed - exception: {e}")
                
    def record_command_success(self):
        """Record successful command execution."""
        self.consecutive_errors = 0
        
    def record_command_error(self, error_msg):
        """Record command error and update error rate."""
        self.error_count += 1
        self.consecutive_errors += 1
        
        if self.consecutive_errors <= 3:  # Don't spam logs
            self.get_logger().warn(f"Command error: {error_msg} (total errors: {self.error_count}, consecutive: {self.consecutive_errors})")
        
    def cmd_vel_callback(self, msg):
        """Handle velocity commands from /cmd_vel topic."""
        if not self.connected:
            self.get_logger().warn("Controller not connected, ignoring cmd_vel")
            return
            
        # Convert twist to wheel velocities (differential drive kinematics)
        linear_vel = msg.linear.x  # m/s
        angular_vel = msg.angular.z  # rad/s
        
        # Calculate wheel velocities
        left_wheel_vel = linear_vel - (angular_vel * self.wheel_separation / 2.0)  # m/s
        right_wheel_vel = linear_vel + (angular_vel * self.wheel_separation / 2.0)  # m/s
        
        # Convert to encoder counts/sec
        left_speed = int(left_wheel_vel * self.counts_per_meter)
        right_speed = int(right_wheel_vel * self.counts_per_meter)
        
        # Apply safety limits
        left_speed = max(-self.max_speed, min(self.max_speed, left_speed))
        right_speed = max(-self.max_speed, min(self.max_speed, right_speed))
        
        # Send commands to controller (trust library's retry mechanism)
        with self.controller_lock:
            try:
                result = self.controller.SpeedM1M2(self.address, right_speed, left_speed)
                if result:
                    self.record_command_success()
                    self.get_logger().debug(f"Speed command sent: L={left_speed}, R={right_speed}")
                else:
                    self.record_command_error("Speed command failed")
                    
            except Exception as e:
                self.record_command_error(f"Speed command exception: {e}")
                
    def read_sensors(self):
        """Read sensor data from the controller."""
        if not self.connected:
            return
            
        with self.controller_lock:
            encoder_success = False
            speed_success = False
            
            # Read encoders (trust library's retry mechanism)
            try:
                encoders = self.controller.GetEncoders(self.address)
                if encoders[0]:  # Success
                    # Handle encoder values (32-bit signed)
                    left_enc_raw = encoders[2]  # Motor 1 (left)
                    right_enc_raw = encoders[1]  # Motor 2 (right)
                    
                    # Convert to signed 32-bit
                    if left_enc_raw > 2147483647:
                        left_enc_raw -= 4294967296
                    if right_enc_raw > 2147483647:
                        right_enc_raw -= 4294967296
                    
                    # Calculate positions in radians
                    self.position_left = left_enc_raw * self.radians_per_count
                    self.position_right = right_enc_raw * self.radians_per_count
                    
                    encoder_success = True
                    self.record_command_success()
                else:
                    self.record_command_error("Encoder read failed")
                    
            except Exception as e:
                self.record_command_error(f"Encoder read exception: {e}")
            
            # Read speeds (trust library's retry mechanism)
            try:
                speeds = self.controller.GetSpeeds(self.address)
                if speeds[0]:  # Success
                    # Convert speeds to rad/s
                    left_speed_raw = speeds[2]  # Motor 1 (left)
                    right_speed_raw = speeds[1]  # Motor 2 (right)
                    
                    # Convert to signed
                    if left_speed_raw > 2147483647:
                        left_speed_raw -= 4294967296
                    if right_speed_raw > 2147483647:
                        right_speed_raw -= 4294967296
                    
                    self.velocity_left = left_speed_raw * self.radians_per_count
                    self.velocity_right = right_speed_raw * self.radians_per_count
                    
                    speed_success = True
                    self.record_command_success()
                else:
                    self.record_command_error("Speed read failed")
                    
            except Exception as e:
                self.record_command_error(f"Speed read exception: {e}")
            
            # Publish joint states if we have data
            if encoder_success or speed_success:
                self.publish_joint_states()
                
    def publish_joint_states(self):
        """Publish joint state data."""
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = "base_link"
        
        msg.name = ["left_wheel_joint", "right_wheel_joint"]
        msg.position = [self.position_left, self.position_right]
        msg.velocity = [self.velocity_left, self.velocity_right]
        msg.effort = [0.0, 0.0]  # No effort feedback available
        
        self.joint_state_pub.publish(msg)
        
    def publish_diagnostics(self):
        """Publish diagnostic information."""
        if not self.connected:
            return
            
        diag_array = DiagnosticArray()
        diag_array.header.stamp = self.get_clock().now().to_msg()
        
        # Controller status
        status = DiagnosticStatus()
        status.name = "basicmicro_controller"
        status.level = DiagnosticStatus.OK
        status.message = "Controller operational"
        
        with self.controller_lock:
            # Read voltages (trust library's retry mechanism)
            try:
                voltages = self.controller.GetVolts(self.address)
                if voltages[0]:
                    main_voltage = voltages[1] / 10.0  # Convert to volts
                    logic_voltage = voltages[2] / 10.0
                    
                    status.values.append(KeyValue(key="main_battery_voltage", value=f"{main_voltage:.1f}V"))
                    status.values.append(KeyValue(key="logic_battery_voltage", value=f"{logic_voltage:.1f}V"))
                    
                    if main_voltage < 12.0:
                        status.level = DiagnosticStatus.WARN
                        status.message = "Low main battery voltage"
                    
                    self.record_command_success()
                else:
                    self.record_command_error("Voltage read failed")
                    
            except Exception as e:
                self.record_command_error(f"Voltage read exception: {e}")
            
            # Read temperatures (trust library's retry mechanism)
            try:
                temps = self.controller.GetTemps(self.address)
                if temps[0]:
                    temp1 = temps[1] / 10.0
                    temp2 = temps[2] / 10.0
                    
                    status.values.append(KeyValue(key="temperature_1", value=f"{temp1:.1f}°C"))
                    status.values.append(KeyValue(key="temperature_2", value=f"{temp2:.1f}°C"))
                    
                    if temp1 > 60.0 or temp2 > 60.0:
                        status.level = DiagnosticStatus.WARN
                        status.message = "High temperature"
                    
                    self.record_command_success()
                else:
                    self.record_command_error("Temperature read failed")
                    
            except Exception as e:
                self.record_command_error(f"Temperature read exception: {e}")
            
            # Add connection info and error statistics
            status.values.append(KeyValue(key="port", value=self.port))
            status.values.append(KeyValue(key="baud_rate", value=str(self.baud)))
            status.values.append(KeyValue(key="address", value=str(self.address)))
            status.values.append(KeyValue(key="connection_state", value=self.connection_state))
            status.values.append(KeyValue(key="error_count", value=str(self.error_count)))
            status.values.append(KeyValue(key="consecutive_errors", value=str(self.consecutive_errors)))
            
            # Update diagnostic status based on connection health
            if self.connection_state == "failed":
                status.level = DiagnosticStatus.ERROR
                status.message = f"Connection failed - error count: {self.error_count}"
            elif self.connection_state == "degraded":
                status.level = DiagnosticStatus.WARN
                status.message = f"Connection degraded - consecutive errors: {self.consecutive_errors}"
                
        diag_array.status.append(status)
        self.diagnostics_pub.publish(diag_array)
        
    def destroy_node(self):
        """Clean shutdown of the node."""
        # Stop monitoring timers
        try:
            if hasattr(self, 'connection_monitor_timer'):
                self.connection_monitor_timer.cancel()
        except Exception as e:
            self.get_logger().error(f"Error cancelling connection monitor timer: {e}")
            
        if self.connected and self.controller:
            try:
                # Stop motors immediately for safety
                self.get_logger().info("Stopping motors for safety...")
                self.controller.DutyM1M2(self.address, 0, 0)
                time.sleep(0.1)  # Give motors time to stop
                self.controller.close()
                self.get_logger().info("Motors stopped and hardware connection closed")
            except Exception as e:
                self.get_logger().error(f"Error during shutdown: {e}")
        super().destroy_node()


def main(args=None):
    """Main entry point for the basicmicro_node."""
    rclpy.init(args=args)
    
    node = None
    try:
        node = BasicmicroNode()
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\nShutting down... Stopping motors for safety.")
    except Exception as e:
        print(f"Error in basicmicro_node: {e}")
    finally:
        # Ensure motors are stopped on exit
        if node is not None:
            node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()


if __name__ == '__main__':
    main()