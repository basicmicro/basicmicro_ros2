#!/usr/bin/env python3

"""
Basicmicro Driver Launch File
=============================

This launch file provides a comprehensive setup for the Basicmicro motor controller
driver with ros2_control integration, monitoring, and diagnostic systems.

Usage Examples:
  # Basic differential drive robot
  ros2 launch basicmicro_driver basicmicro_driver.launch.py robot_config:=diff_drive

  # Industrial robot with custom parameters
  ros2 launch basicmicro_driver basicmicro_driver.launch.py \
    robot_config:=industrial \
    port:=/dev/ttyACM0 \
    baud:=38400 \
    address:=128

  # Multi-controller setup
  ros2 launch basicmicro_driver basicmicro_driver.launch.py \
    robot_config:=multi_controller \
    enable_monitoring:=true \
    monitoring_rate:=50.0

  # Custom robot description
  ros2 launch basicmicro_driver basicmicro_driver.launch.py \
    robot_description_file:=/path/to/custom_robot.urdf.xacro

Author: Generated by Claude Code for Basicmicro ROS2 Driver
License: Apache-2.0
"""

from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, OpaqueFunction, GroupAction
from launch.actions import ExecuteProcess, IncludeLaunchDescription
from launch.conditions import IfCondition, UnlessCondition
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution, Command
from launch.substitutions import FindExecutable, TextSubstitution
from launch_ros.actions import Node, LoadComposableNodes
from launch_ros.descriptions import ComposableNode
from launch_ros.substitutions import FindPackageShare
from launch.launch_description_sources import PythonLaunchDescriptionSource
import os
from pathlib import Path


def generate_launch_description():
    """Generate the launch description for the Basicmicro driver system."""
    
    # Package directories
    pkg_share = FindPackageShare('basicmicro_driver')
    
    # Launch arguments with defaults
    launch_args = [
        # Robot configuration
        DeclareLaunchArgument(
            'robot_config',
            default_value='diff_drive',
            description='Robot configuration type: diff_drive, industrial, multi_controller, custom'
        ),
        DeclareLaunchArgument(
            'robot_description_file',
            default_value='',
            description='Path to custom robot URDF/XACRO file (overrides robot_config)'
        ),
        
        # Hardware connection parameters
        DeclareLaunchArgument(
            'port',
            default_value='/dev/ttyACM0',
            description='Serial port for Basicmicro controller'
        ),
        DeclareLaunchArgument(
            'baud',
            default_value='38400',
            description='Baud rate for serial communication'
        ),
        DeclareLaunchArgument(
            'address',
            default_value='128',
            description='Controller address (0x80 = 128)'
        ),
        
        # Robot physical parameters
        DeclareLaunchArgument(
            'wheel_radius',
            default_value='0.1',
            description='Wheel radius in meters'
        ),
        DeclareLaunchArgument(
            'wheel_separation',
            default_value='0.3',
            description='Distance between wheels in meters'
        ),
        DeclareLaunchArgument(
            'encoder_counts_per_rev',
            default_value='1000',
            description='Encoder counts per revolution'
        ),
        DeclareLaunchArgument(
            'gear_ratio',
            default_value='1.0',
            description='Gear ratio between motor and wheel'
        ),
        
        # Motion control parameters
        DeclareLaunchArgument(
            'motion_strategy',
            default_value='speed_accel',
            description='Motion control strategy: duty, duty_accel, speed, speed_accel'
        ),
        DeclareLaunchArgument(
            'default_acceleration',
            default_value='1000',
            description='Default acceleration in encoder counts/secÂ²'
        ),
        DeclareLaunchArgument(
            'buffer_depth',
            default_value='4',
            description='Command buffer depth (1-32)'
        ),
        
        # Servo functionality parameters
        DeclareLaunchArgument(
            'encoder_type',
            default_value='incremental',
            description='Encoder type: incremental or absolute'
        ),
        DeclareLaunchArgument(
            'auto_home_on_startup',
            default_value='false',
            description='Enable automatic homing on startup (RoboClaw only)'
        ),
        DeclareLaunchArgument(
            'position_limits_enabled',
            default_value='false',
            description='Enable position limits for non-position commands'
        ),
        
        # Monitoring and diagnostics
        DeclareLaunchArgument(
            'enable_monitoring',
            default_value='true',
            description='Enable trajectory and performance monitoring'
        ),
        DeclareLaunchArgument(
            'monitoring_rate',
            default_value='25.0',
            description='Monitoring rate in Hz (10-50 recommended)'
        ),
        DeclareLaunchArgument(
            'enable_diagnostics',
            default_value='true',
            description='Enable diagnostic publishing'
        ),
        DeclareLaunchArgument(
            'diagnostic_rate',
            default_value='2.0',
            description='Diagnostic publishing rate in Hz'
        ),
        DeclareLaunchArgument(
            'enable_performance_monitoring',
            default_value='true',
            description='Enable performance monitoring and optimization'
        ),
        DeclareLaunchArgument(
            'performance_monitoring_rate',
            default_value='10.0',
            description='Performance monitoring rate in Hz'
        ),
        
        # Controller configuration
        DeclareLaunchArgument(
            'controller_config_file',
            default_value='',
            description='Path to controller configuration file'
        ),
        DeclareLaunchArgument(
            'spawn_controllers',
            default_value='true',
            description='Automatically spawn and start controllers'
        ),
        
        # Debugging and logging
        DeclareLaunchArgument(
            'log_level',
            default_value='info',
            description='ROS2 log level: debug, info, warn, error'
        ),
        DeclareLaunchArgument(
            'use_sim_time',
            default_value='false',
            description='Use simulation time'
        ),
        
        # Service enabling
        DeclareLaunchArgument(
            'enable_motion_services',
            default_value='true',
            description='Enable motion control services'
        ),
        DeclareLaunchArgument(
            'enable_servo_services',
            default_value='true',
            description='Enable servo position control services'
        ),
        DeclareLaunchArgument(
            'enable_trajectory_services',
            default_value='true',
            description='Enable trajectory execution services'
        ),
    ]
    
    def launch_setup(context, *args, **kwargs):
        """Setup function called with context to access launch arguments."""
        
        # Get launch configuration values
        robot_config = LaunchConfiguration('robot_config').perform(context)
        robot_description_file = LaunchConfiguration('robot_description_file').perform(context)
        controller_config_file = LaunchConfiguration('controller_config_file').perform(context)
        
        # Determine robot description file
        if robot_description_file:
            urdf_file = robot_description_file
        else:
            # Use predefined robot configuration from urdf/ directory
            config_files = {
                'diff_drive': 'differential_drive_robot.urdf.xacro',
                'industrial': 'industrial_robot.urdf.xacro', 
                'multi_controller': 'multi_controller_robot.urdf.xacro',
                'custom': 'custom_robot.urdf.xacro'
            }
            urdf_file = PathJoinSubstitution([
                pkg_share, 'urdf', config_files.get(robot_config, 'differential_drive_robot.urdf.xacro')
            ])
        
        # Generate robot description
        robot_description_content = Command([
            FindExecutable(name='xacro'),
            ' ',
            urdf_file,
            ' port:=', LaunchConfiguration('port'),
            ' baud:=', LaunchConfiguration('baud'),
            ' address:=', LaunchConfiguration('address'),
            ' wheel_radius:=', LaunchConfiguration('wheel_radius'),
            ' wheel_separation:=', LaunchConfiguration('wheel_separation'),
            ' encoder_counts_per_rev:=', LaunchConfiguration('encoder_counts_per_rev'),
            ' gear_ratio:=', LaunchConfiguration('gear_ratio'),
            ' motion_strategy:=', LaunchConfiguration('motion_strategy'),
            ' default_acceleration:=', LaunchConfiguration('default_acceleration'),
            ' buffer_depth:=', LaunchConfiguration('buffer_depth'),
            ' encoder_type:=', LaunchConfiguration('encoder_type'),
            ' auto_home_on_startup:=', LaunchConfiguration('auto_home_on_startup'),
            ' position_limits_enabled:=', LaunchConfiguration('position_limits_enabled'),
        ])
        
        # Determine controller configuration file
        if controller_config_file:
            controllers_file = controller_config_file
        else:
            # Use predefined controller configuration from config/ directory
            controllers_file = PathJoinSubstitution([
                pkg_share, 'config', f'{robot_config}_controllers.yaml'
            ])
        
        actions = []
        
        # Robot State Publisher
        robot_state_publisher = Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            output='screen',
            parameters=[{
                'robot_description': robot_description_content,
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(robot_state_publisher)
        
        # Joint State Broadcaster (for visualization)
        joint_state_broadcaster_spawner = Node(
            package='controller_manager',
            executable='spawner',
            arguments=['joint_state_broadcaster', '--controller-manager', '/controller_manager'],
            condition=IfCondition(LaunchConfiguration('spawn_controllers')),
        )
        actions.append(joint_state_broadcaster_spawner)
        
        # Controller Manager
        controller_manager = Node(
            package='controller_manager',
            executable='ros2_control_node',
            parameters=[
                {'robot_description': robot_description_content},
                controllers_file,
                {'use_sim_time': LaunchConfiguration('use_sim_time')},
            ],
            output='screen',
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(controller_manager)
        
        # Differential Drive Controller (most common use case)
        diff_drive_spawner = Node(
            package='controller_manager', 
            executable='spawner',
            arguments=['diff_drive_controller', '--controller-manager', '/controller_manager'],
            condition=IfCondition(LaunchConfiguration('spawn_controllers')),
        )
        actions.append(diff_drive_spawner)
        
        # Motion Configuration Service
        motion_config_service = Node(
            package='basicmicro_driver',
            executable='motion_config_service_node',
            name='motion_config_service',
            output='screen',
            parameters=[{
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_motion_services')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(motion_config_service)
        
        # Distance Movement Service
        distance_movement_service = Node(
            package='basicmicro_driver',
            executable='distance_movement_service_node',
            name='distance_movement_service',
            output='screen',
            parameters=[{
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_motion_services')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(distance_movement_service)
        
        # Trajectory Execution Service
        trajectory_service = Node(
            package='basicmicro_driver',
            executable='trajectory_service_node',
            name='trajectory_service',
            output='screen',
            parameters=[{
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_trajectory_services')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(trajectory_service)
        
        # Servo Position Control Service
        servo_position_service = Node(
            package='basicmicro_driver',
            executable='servo_position_service_node', 
            name='servo_position_service',
            output='screen',
            parameters=[{
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_servo_services')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(servo_position_service)
        
        # Duty Control Service
        duty_control_service = Node(
            package='basicmicro_driver',
            executable='duty_control_service_node',
            name='duty_control_service',
            output='screen',
            parameters=[{
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_motion_services')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(duty_control_service)
        
        # Trajectory Monitor
        trajectory_monitor = Node(
            package='basicmicro_driver',
            executable='trajectory_monitor_node',
            name='trajectory_monitor',
            output='screen',
            parameters=[{
                'monitoring_rate': LaunchConfiguration('monitoring_rate'),
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_monitoring')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(trajectory_monitor)
        
        # Diagnostic Publisher
        diagnostic_publisher = Node(
            package='basicmicro_driver',
            executable='diagnostic_publisher_node',
            name='diagnostic_publisher',
            output='screen',
            parameters=[{
                'diagnostic_rate': LaunchConfiguration('diagnostic_rate'),
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_diagnostics')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(diagnostic_publisher)
        
        # Performance Monitor
        performance_monitor = Node(
            package='basicmicro_driver',
            executable='performance_monitor_node',
            name='performance_monitor',
            output='screen',
            parameters=[{
                'monitoring_rate': LaunchConfiguration('performance_monitoring_rate'),
                'use_sim_time': LaunchConfiguration('use_sim_time'),
            }],
            condition=IfCondition(LaunchConfiguration('enable_performance_monitoring')),
            arguments=['--ros-args', '--log-level', LaunchConfiguration('log_level')]
        )
        actions.append(performance_monitor)
        
        return actions
    
    # Create launch description with arguments and opaque function
    ld = LaunchDescription(launch_args)
    ld.add_action(OpaqueFunction(function=launch_setup))
    
    return ld


if __name__ == '__main__':
    generate_launch_description()