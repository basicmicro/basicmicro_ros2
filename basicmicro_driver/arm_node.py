#!/usr/bin/env python3

"""
Two-Axis Arm ROS2 Node with Servo Position Control
===================================================

ROS2 node for controlling a 2-DOF robotic arm using Basicmicro motor controllers
with servo positioning capabilities. Integrates with the servo_position_service
for absolute positioning, homing, and trajectory execution.

Features:
- Absolute joint positioning with encoder feedback
- Forward/inverse kinematics for Cartesian control
- Trajectory execution with buffer management
- Homing and calibration capabilities
- Real-time joint state publishing
- MoveIt! integration ready
- Safety monitoring and limits

Author: Generated by Claude Code for Basicmicro ROS2 Driver
License: Apache-2.0
"""

import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from geometry_msgs.msg import Point, Pose, Quaternion
from sensor_msgs.msg import JointState
from std_msgs.msg import String, Float32, Bool
from diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue
from tf2_ros import TransformBroadcaster
from geometry_msgs.msg import TransformStamped
import sys
import os

# Add the Basicmicro_python directory to Python path
sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'Basicmicro_python'))

try:
    from basicmicro import Basicmicro
except ImportError as e:
    print(f"Error importing Basicmicro library: {e}")
    print("Make sure the Basicmicro_python library is installed")
    sys.exit(1)

# Import local modules
try:
    from basicmicro_driver.hardware_interface import BasicmicroHardwareInterface
    from basicmicro_driver.servo_position_service import ServoPositionService
    from basicmicro_driver.unit_converter import UnitConverter
    from basicmicro_driver.buffer_manager import BufferManager
except ImportError:
    try:
        # Fallback for relative import in package context
        from .hardware_interface import BasicmicroHardwareInterface
        from .servo_position_service import ServoPositionService
        from .unit_converter import UnitConverter
        from .buffer_manager import BufferManager
    except ImportError:
        # Direct import fallback
        import sys
        import os
        current_dir = os.path.dirname(os.path.abspath(__file__))
        sys.path.insert(0, current_dir)
        from hardware_interface import BasicmicroHardwareInterface
        from servo_position_service import ServoPositionService
        from unit_converter import UnitConverter
        from buffer_manager import BufferManager

import math
import time
import numpy as np
from threading import Lock
from typing import Tuple, List, Optional


class ArmKinematics:
    """Forward and inverse kinematics for 2-DOF arm"""
    
    def __init__(self, link1_length: float, link2_length: float):
        self.link1_length = link1_length
        self.link2_length = link2_length
    
    def forward_kinematics(self, joint1: float, joint2: float) -> Tuple[float, float, float]:
        """
        Calculate end-effector position from joint angles
        
        Args:
            joint1: Shoulder joint angle (radians)
            joint2: Elbow joint angle (radians)
            
        Returns:
            Tuple of (x, y, z) position in meters
        """
        # Forward kinematics for 2-DOF arm
        x = self.link1_length * math.cos(joint1) + self.link2_length * math.cos(joint1 + joint2)
        y = self.link1_length * math.sin(joint1) + self.link2_length * math.sin(joint1 + joint2)
        z = 0.0  # Planar arm
        
        return x, y, z
    
    def inverse_kinematics(self, x: float, y: float) -> Tuple[bool, float, float]:
        """
        Calculate joint angles from end-effector position
        
        Args:
            x: Target X position (meters)
            y: Target Y position (meters)
            
        Returns:
            Tuple of (success, joint1, joint2) angles in radians
        """
        # Distance to target
        r = math.sqrt(x*x + y*y)
        
        # Check if target is reachable
        if r > (self.link1_length + self.link2_length):
            return False, 0.0, 0.0  # Too far
        if r < abs(self.link1_length - self.link2_length):
            return False, 0.0, 0.0  # Too close
        
        # Calculate joint2 using law of cosines
        cos_joint2 = (r*r - self.link1_length*self.link1_length - self.link2_length*self.link2_length) / (2 * self.link1_length * self.link2_length)
        
        # Clamp to valid range
        cos_joint2 = max(-1.0, min(1.0, cos_joint2))
        joint2 = math.acos(cos_joint2)
        
        # Calculate joint1
        alpha = math.atan2(y, x)
        beta = math.atan2(self.link2_length * math.sin(joint2), self.link1_length + self.link2_length * math.cos(joint2))
        joint1 = alpha - beta
        
        return True, joint1, joint2


class ArmNode(Node):
    """Two-Axis Arm ROS2 node with servo position control."""
    
    def __init__(self):
        super().__init__('arm_node')
        
        # Declare parameters
        self.declare_parameter('port', '/dev/ttyACM1')
        self.declare_parameter('baud', 38400)
        self.declare_parameter('address', 128)  # 0x80
        self.declare_parameter('link1_length', 0.3)  # meters
        self.declare_parameter('link2_length', 0.25)  # meters
        self.declare_parameter('joint1_limits', [-math.pi, math.pi])  # radians
        self.declare_parameter('joint2_limits', [-math.pi/2, math.pi/2])  # radians
        self.declare_parameter('max_velocity', 2.0)  # rad/s
        self.declare_parameter('max_acceleration', 5.0)  # rad/sÂ²
        self.declare_parameter('gear_ratio', 50.0)
        self.declare_parameter('encoder_counts_per_rev', 2000)
        self.declare_parameter('homing_on_startup', False)
        
        # Get parameters
        self.port = self.get_parameter('port').get_parameter_value().string_value
        self.baud = self.get_parameter('baud').get_parameter_value().integer_value
        self.address = self.get_parameter('address').get_parameter_value().integer_value
        self.link1_length = self.get_parameter('link1_length').get_parameter_value().double_value
        self.link2_length = self.get_parameter('link2_length').get_parameter_value().double_value
        self.joint1_limits = self.get_parameter('joint1_limits').get_parameter_value().double_array_value
        self.joint2_limits = self.get_parameter('joint2_limits').get_parameter_value().double_array_value
        self.max_velocity = self.get_parameter('max_velocity').get_parameter_value().double_value
        self.max_acceleration = self.get_parameter('max_acceleration').get_parameter_value().double_value
        self.gear_ratio = self.get_parameter('gear_ratio').get_parameter_value().double_value
        self.encoder_counts_per_rev = self.get_parameter('encoder_counts_per_rev').get_parameter_value().integer_value
        self.homing_on_startup = self.get_parameter('homing_on_startup').get_parameter_value().bool_value
        
        # Initialize kinematics
        self.kinematics = ArmKinematics(self.link1_length, self.link2_length)
        
        # Initialize hardware interface
        self.hardware_interface = None
        self.connected = False
        self.controller_lock = Lock()
        
        # Initialize supporting modules
        self.unit_converter = UnitConverter(
            wheel_radius=0.01,  # Not used for arm (small dummy value)
            encoder_counts_per_rev=self.encoder_counts_per_rev,
            gear_ratio=self.gear_ratio
        )
        
        self.buffer_manager = BufferManager(self.hardware_interface)
        
        # Joint state tracking
        self.joint_positions = [0.0, 0.0]  # radians
        self.joint_velocities = [0.0, 0.0]  # rad/s
        self.joint_efforts = [0.0, 0.0]  # estimated from current
        self.last_update_time = time.time()
        
        # End-effector state
        self.end_effector_pose = Pose()
        self.update_end_effector_pose()
        
        # ROS2 Publishers
        self.joint_state_pub = self.create_publisher(JointState, 'joint_states', 10)
        self.diagnostics_pub = self.create_publisher(DiagnosticArray, 'diagnostics', 10)
        self.status_pub = self.create_publisher(String, 'arm/status', 10)
        self.end_effector_pub = self.create_publisher(Pose, 'arm/end_effector_pose', 10)
        
        # ROS2 Subscribers
        self.joint_cmd_sub = self.create_subscription(
            JointState, 'arm/joint_commands', self.joint_command_callback, 10)
        self.cartesian_cmd_sub = self.create_subscription(
            Point, 'arm/cartesian_commands', self.cartesian_command_callback, 10)
        self.home_cmd_sub = self.create_subscription(
            Bool, 'arm/home_command', self.home_command_callback, 10)
        
        # TF broadcaster
        self.tf_broadcaster = TransformBroadcaster(self)
        
        # Connect to hardware
        self.connect_hardware()
        
        # Initialize servo position service
        if self.hardware_interface:
            self.servo_service = ServoPositionService(
                self.hardware_interface, 
                self.buffer_manager, 
                self.unit_converter
            )
        else:
            self.servo_service = None
            self.get_logger().warn("Servo position service not available without hardware")
        
        # Perform homing if requested
        if self.homing_on_startup and self.servo_service:
            self.get_logger().info("Performing startup homing...")
            self.perform_startup_homing()
        
        # Create timers
        self.sensor_timer = self.create_timer(0.02, self.update_state)  # 50Hz
        self.diagnostics_timer = self.create_timer(1.0, self.publish_diagnostics)  # 1Hz
        self.tf_timer = self.create_timer(0.05, self.publish_transforms)  # 20Hz
        
        self.get_logger().info(f"Arm node initialized - Port: {self.port}, Address: {self.address}")
        self.get_logger().info(f"Arm configuration: L1={self.link1_length}m, L2={self.link2_length}m")
    
    def connect_hardware(self):
        """Connect to Basicmicro hardware"""
        try:
            self.hardware_interface = BasicmicroHardwareInterface(
                port=self.port,
                baud_rate=self.baud,
                address=self.address
            )
            
            # Test hardware connection (USB Serial or Async Serial)
            if hasattr(self.hardware_interface, 'controller') and self.hardware_interface.controller:
                version_result = self.hardware_interface.controller.ReadVersion(self.address)
                if version_result[0]:  # Success
                    self.connected = True
                    version_string = version_result[1].strip()
                    self.get_logger().info(f"Connected to controller: {version_string}")
                else:
                    self.get_logger().error("Failed to read controller version")
            else:
                self.get_logger().error("Failed to create hardware interface")
                
        except Exception as e:
            self.get_logger().error(f"Hardware connection failed: {e}")
            self.connected = False
    
    def perform_startup_homing(self):
        """Perform startup homing sequence"""
        if not self.servo_service:
            self.get_logger().warn("Cannot perform homing - servo service not available")
            return
            
        try:
            # Perform manual zero homing for both joints
            success, message, encoder_zeroed = self.servo_service.perform_homing(
                "manual_zero", "both", 0.1, 5.0
            )
            
            if success and encoder_zeroed:
                self.get_logger().info(f"Startup homing completed: {message}")
                self.joint_positions = [0.0, 0.0]
                self.update_end_effector_pose()
            else:
                self.get_logger().warn(f"Startup homing failed: {message}")
                
        except Exception as e:
            self.get_logger().error(f"Startup homing error: {e}")
    
    def joint_command_callback(self, msg: JointState):
        """Handle joint position commands"""
        if len(msg.position) >= 2 and self.servo_service:
            joint1_cmd = msg.position[0]
            joint2_cmd = msg.position[1]
            
            # Apply joint limits
            joint1_cmd = max(self.joint1_limits[0], min(self.joint1_limits[1], joint1_cmd))
            joint2_cmd = max(self.joint2_limits[0], min(self.joint2_limits[1], joint2_cmd))
            
            # Send position command
            success, message = self.servo_service.move_to_absolute_position(
                joint1_cmd, joint2_cmd,
                self.max_velocity, self.max_acceleration, self.max_acceleration,
                buffer_command=False
            )
            
            if success:
                self.get_logger().info(f"Joint command sent: J1={joint1_cmd:.3f}, J2={joint2_cmd:.3f}")
            else:
                self.get_logger().warn(f"Joint command failed: {message}")
    
    def cartesian_command_callback(self, msg: Point):
        """Handle Cartesian position commands"""
        # Use inverse kinematics to calculate joint angles
        success, joint1, joint2 = self.kinematics.inverse_kinematics(msg.x, msg.y)
        
        if success:
            # Create joint command
            joint_cmd = JointState()
            joint_cmd.position = [joint1, joint2]
            self.joint_command_callback(joint_cmd)
            
            self.get_logger().info(f"Cartesian command: ({msg.x:.3f}, {msg.y:.3f}) -> J1={joint1:.3f}, J2={joint2:.3f}")
        else:
            self.get_logger().warn(f"Cartesian target unreachable: ({msg.x:.3f}, {msg.y:.3f})")
    
    def home_command_callback(self, msg: Bool):
        """Handle homing command"""
        if msg.data and self.servo_service:
            self.get_logger().info("Manual homing requested...")
            self.perform_startup_homing()
    
    def update_state(self):
        """Update joint states from hardware"""
        if not self.connected or not self.hardware_interface:
            return
            
        try:
            with self.controller_lock:
                # Read encoder positions
                encoders_result = self.hardware_interface.controller.GetEncoders(self.address)
                if encoders_result[0]:  # Success
                    encoder1 = encoders_result[1]
                    encoder2 = encoders_result[2]
                    
                    # Convert to radians
                    self.joint_positions[0] = self.unit_converter.counts_to_radians(encoder1)
                    self.joint_positions[1] = self.unit_converter.counts_to_radians(encoder2)
                
                # Read instantaneous speeds for velocity
                speeds_result = self.hardware_interface.controller.GetISpeeds(self.address)
                if speeds_result[0]:  # Success
                    speed1 = speeds_result[1]
                    speed2 = speeds_result[2]
                    
                    # Convert to rad/s
                    self.joint_velocities[0] = self.unit_converter.counts_per_sec_to_rad_per_sec(speed1)
                    self.joint_velocities[1] = self.unit_converter.counts_per_sec_to_rad_per_sec(speed2)
                
                # Read currents for effort estimation
                currents_result = self.hardware_interface.controller.ReadCurrents(self.address)
                if currents_result[0]:  # Success
                    current1 = currents_result[1] / 1000.0  # Convert mA to A
                    current2 = currents_result[2] / 1000.0
                    
                    # Estimate torque from current (simplified)
                    self.joint_efforts[0] = current1 * 0.1  # Nm per A (example)
                    self.joint_efforts[1] = current2 * 0.1
            
            # Update end-effector pose
            self.update_end_effector_pose()
            
            # Publish joint states
            self.publish_joint_states()
            
        except Exception as e:
            self.get_logger().error(f"State update error: {e}")
    
    def update_end_effector_pose(self):
        """Update end-effector pose from joint positions"""
        x, y, z = self.kinematics.forward_kinematics(
            self.joint_positions[0], self.joint_positions[1]
        )
        
        self.end_effector_pose.position.x = x
        self.end_effector_pose.position.y = y
        self.end_effector_pose.position.z = z
        
        # For now, orientation is just the sum of joint angles (simplified)
        total_angle = self.joint_positions[0] + self.joint_positions[1]
        self.end_effector_pose.orientation.z = math.sin(total_angle / 2.0)
        self.end_effector_pose.orientation.w = math.cos(total_angle / 2.0)
    
    def publish_joint_states(self):
        """Publish joint states"""
        joint_state = JointState()
        joint_state.header.stamp = self.get_clock().now().to_msg()
        joint_state.name = ['joint1', 'joint2']
        joint_state.position = self.joint_positions
        joint_state.velocity = self.joint_velocities
        joint_state.effort = self.joint_efforts
        
        self.joint_state_pub.publish(joint_state)
        
        # Also publish end-effector pose
        self.end_effector_pub.publish(self.end_effector_pose)
    
    def publish_transforms(self):
        """Publish TF transforms"""
        # Base to end-effector transform
        t = TransformStamped()
        t.header.stamp = self.get_clock().now().to_msg()
        t.header.frame_id = 'base_link'
        t.child_frame_id = 'end_effector'
        
        t.transform.translation.x = self.end_effector_pose.position.x
        t.transform.translation.y = self.end_effector_pose.position.y
        t.transform.translation.z = self.end_effector_pose.position.z
        
        t.transform.rotation = self.end_effector_pose.orientation
        
        self.tf_broadcaster.sendTransform(t)
    
    def publish_diagnostics(self):
        """Publish diagnostic information"""
        diag_array = DiagnosticArray()
        diag_array.header.stamp = self.get_clock().now().to_msg()
        
        # Hardware status
        hw_status = DiagnosticStatus()
        hw_status.name = "Arm Hardware"
        hw_status.hardware_id = f"Basicmicro@{self.port}"
        
        if self.connected:
            hw_status.level = DiagnosticStatus.OK
            hw_status.message = "Hardware connected and operational"
        else:
            hw_status.level = DiagnosticStatus.ERROR
            hw_status.message = "Hardware connection failed"
        
        hw_status.values.append(KeyValue(key="Port", value=self.port))
        hw_status.values.append(KeyValue(key="Address", value=str(self.address)))
        hw_status.values.append(KeyValue(key="Connected", value=str(self.connected)))
        
        # Joint status
        joint_status = DiagnosticStatus()
        joint_status.name = "Arm Joints"
        joint_status.hardware_id = f"Joints@{self.address}"
        joint_status.level = DiagnosticStatus.OK
        joint_status.message = "Joints operational"
        
        joint_status.values.append(KeyValue(key="Joint1 Position", value=f"{self.joint_positions[0]:.3f} rad"))
        joint_status.values.append(KeyValue(key="Joint2 Position", value=f"{self.joint_positions[1]:.3f} rad"))
        joint_status.values.append(KeyValue(key="Joint1 Velocity", value=f"{self.joint_velocities[0]:.3f} rad/s"))
        joint_status.values.append(KeyValue(key="Joint2 Velocity", value=f"{self.joint_velocities[1]:.3f} rad/s"))
        
        # End-effector status
        ee_status = DiagnosticStatus()
        ee_status.name = "End Effector"
        ee_status.hardware_id = "EndEffector"
        ee_status.level = DiagnosticStatus.OK
        ee_status.message = "End effector tracking"
        
        ee_status.values.append(KeyValue(key="X Position", value=f"{self.end_effector_pose.position.x:.3f} m"))
        ee_status.values.append(KeyValue(key="Y Position", value=f"{self.end_effector_pose.position.y:.3f} m"))
        ee_status.values.append(KeyValue(key="Z Position", value=f"{self.end_effector_pose.position.z:.3f} m"))
        
        diag_array.status = [hw_status, joint_status, ee_status]
        self.diagnostics_pub.publish(diag_array)
        
        # Publish status string
        status_msg = String()
        if self.connected:
            status_msg.data = f"ARM OK - J1:{self.joint_positions[0]:.2f} J2:{self.joint_positions[1]:.2f} EE:({self.end_effector_pose.position.x:.2f},{self.end_effector_pose.position.y:.2f})"
        else:
            status_msg.data = "ARM ERROR - Hardware disconnected"
        self.status_pub.publish(status_msg)


def main(args=None):
    """Main entry point"""
    rclpy.init(args=args)
    
    try:
        node = ArmNode()
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        if 'node' in locals():
            node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()